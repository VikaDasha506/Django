Django_331 - Учебный проект "Карточки интервального повторения"
Lesson 48
Создание проекта Django_331
Создали репозиторий
Создали проект Django_331
Установили зависимости pip install django==4.2
Сохранили зависимости в файл requirements.txt командой pip freeze > requirements.txt
Развернуть проект на локальной машине:

Склонировать репозиторий командой `git clone
Перейти в папку проекта cd Django_331
Создать виртуальное окружение python -m venv venv
Активировать виртуальное окружение source venv/bin/activate
Установить зависимости pip install -r requirements.txt
Создание Django project
Создать проект django-admin startproject anki . Этой командой мы создадим проект с именем anki в текущей директории. Точка в конце команды означает, что проект будет создан в текущей директории, без создания дополнительной директории с именем проекта.

Запуск проекта python manage.py runserver Для запуска проекта, вам нужно использовать терминал, и находясь в директории проекта, на одном уровне с файлом manage.py, выполнить команду python manage.py runserver Для остановки сервера используйте комбинацию клавиш Ctrl+C

Команды терминала:

python manage.py runserver - запуск сервера
cd - смена директории
cd.. - переход на уровень выше
ls - просмотр содержимого директории
pwd - показать текущую директорию
Создание приложения python manage.py startapp cards После создания приложения, вам нужно зарегистрировать его в файле settings.py в разделе INSTALLED_APPS Без этого, полноценно, приложение не будет работать.
Создали первое представление
from django.http import HttpResponse

def main(request):
    return HttpResponse("Привет, мир!")  # вернет страничку с надписью "Привет, мир!" на русском языке.
Чтобы представление заработало, его нужно зарегистрировать в файле urls.py конфигурации проекта.

Создали первый URL
path('', views.main),
Теперь, если вы перейдете на главную страницу сайта, то увидите надпись "Привет, мир!"

Создаем детальное представление карточки по ее ID
Для этого нам нужно создать новый маршрут, с конвертом int, который будет принимать ID карточки.

path('cards/<int:card_id>/', views.card_detail),
А так же функцию, которая будет обрабатывать запрос и возвращать страницу с детальной информацией о карточке.

def card_by_id(request, card_id):
    return HttpResponse(f"Карточка с ID {card_id}")
include и собственный файл urls.py для приложения cards
Создали еще одно представление get_all_cards в файле views.py
Создали файл urls.py в директории приложения cards
Зарегистрировали новый файл urls.py в файле urls.py конфигурации проекта с помощью функции include
Зарегистрировали маршруты без префикса cards/ в файле urls.py приложения cards
Удалили маршруты cards/ из файла urls.py конфигурации проекта
Lesson 49
Настройка конфигурации запуска в PyCharm
Откройте "Edit Configurations": В PyCharm перейдите в меню "Run" -> "Edit Configurations" для настройки новой конфигурации запуска.
Добавление новой конфигурации: Нажмите на плюсик (+) и выберите тип конфигурации для Python.
Заполнение полей конфигурации:
Название: Дайте конфигурации понятное имя, чтобы вы могли легко идентифицировать её среди других конфигураций.
Рабочая директория: Укажите директорию вашего проекта Django. Это папка, где находится файл manage.py.
Интерпретатор языка: Выберите интерпретатор Python для вашего виртуального окружения, если вы его используете, или глобальный интерпретатор, если виртуальное окружение не настроено.
Script path: Укажите путь к файлу manage.py в вашем проекте Django.
Параметры: Введите runserver, чтобы запустить разработческий сервер Django.
Знакомство с Django Templates (Шаблоны)
Создали папку templates в директории приложения cards
Создали файл catalog.html в директории templates/cards
Переписали функцию get_all_cards в файле views.py так, чтобы она возвращала страницу catalog.html используя функцию render из модуля django.shortcuts
commit: lesson_49: рендер первого шаблона

Работа с шаблоном
Создали словарь с данными в views.py и передали его в шаблон
info = {
    "users_count": 100600,
    "cards_count": 100600,
}
Вставили данные в шаблон catalog.html с помощью шаблонного языка Django
Подключили BS5 по CDN и стилизовали страницу
commit: lesson_49: передал первые данные в шаблон и подключил BS5

Смотрим типы данных внутри шаблона
Проверили, что можем передать экземпляр класса, и вывести его атрибуты в шаблоне
Проверили, что можно передать только словарь
Передали список и вывели его в шаблоне
Передали список меню и познакомились с конструкцией {% for item in menu %}
commit: lesson_49: первый цикл в шаблоне

Посмотрели на тег шаблона if
Сделали <hr> после каждого элемента списка, кроме последнего
commit: lesson_49: первый тег if в шаблоне

Сделали ссылки в меню кликабельными
Передали в шаблон список словарей, где каждый словарь содержит url и title
Осталось протестировать шаблонный тег url!
commit: lesson_49: сделал ссылки в меню кликабельными

Lesson 50
Как получить успешное прохождение тестов из ДЗ №29
Что в urlpatterns нужно писать, чтобы получлся путь типа '/cards/catalog/1/'? Как пройти тест?

Делаем разбор ДЗ Определили, что важнейшую роль играет порядок подключения URL-маршрутов в файле urls.py, отрабатывает первый попавшийся маршрут.

Если первый slug - то он отработает число. Если первый int - то он НЕ будет отрабатывать строку.

commit: hw_29: пофиксили urls.py (порядок имеет значение) и прошли тесты

Изменение структуры cards/url.py и cards/views.py
Изменил пути и функции для дальнейшего развития проекта.

Создание базового шаблона base.html в корне проекта в папке templates
Создали базовый шаблон base.html в папке templates
Указали кастомный, нестандартный путь для Джанго в файле settings.py в разделе TEMPLATES
Прописали там BASE_DIR / 'templates',
Подключили базовый шаблон для теста функции main в файле views.py
commit: lesson_50: создал базовый шаблон base.html

Синтаксис блоков в шаблонах. {% block %} и {% extends %}
Описали блок content в базовом шаблоне base.html
Создали шаблон main.html в папке templates, который расширяет базовый шаблон через {% extends %}
Переопределили блок content в шаблоне main.html через {% block %}
Подключили шаблон main.html в функции main в файле views.py
commit: lesson_50: создал шаблон main.html и расширил базовый шаблон

Создание шаблона nav_menu.html и подключение его в базовом шаблоне через {% include %}
Создали каталог includes в папке templates в корне проекта
Создали шаблон nav_menu.html в папке includes
Написли навигационное меню в шаблоне nav_menu.html
Использовали шаблонный тег {% url %} который позволяет создавать ссылки на страницы по их именам в файле urls.py
Подключили шаблон nav_menu.html в базовом шаблоне base.html через {% include %}
Добавили датасет с карточками и меню, чтобы проверить работу шаблона
commit: lesson_50: создал шаблон nav_menu.html и подключил его в базовом шаблоне

Работа с шаблонами about.html, catalog.html, main.html а так же модификация views.py
Модифицировали все шаблоны, и сделали так, чтобы они наследовались от базового шаблона
Модфицировали соответствующие функции в файле views.py, чтобы они возвращали нужные шаблоны и принимали данные для меню
Наладили рендер меню во всех шаблонах, и получили "сквозное" меню на всех страницах
commit: lesson_50: модифицировал все шаблоны и функции в views.py - сквозная навигация

Начали работу над каталогом карточек (динамическая вставка данных в шаблон, цикл + include)
Создали includes в папке templates в приложении cards
Внутри создали шаблон card_preview.html
Шаблон card_preview.html принимает на вход словарь с данными о карточке и возвращает карточку, которая будет вставлена в каталог карточек в шаблоне catalog.html в цикле #TODO: ДОДЕЛАТЬ!)
commit: lesson_50: начал работу над каталогом карточек и динамической вставкой данных в шаблон

Lesson 51
Продолжили работу над каталогом карточек (динамическая вставка данных в шаблон, цикл + include)
Добавили отсутствующий маршрут в файл urls.py приложения cards (детальное отображение карточки по ID)
Добавили шаблон card_detail.html в папке templates/cards
Доделали include в шаблоне catalog.html и вставили в него карточки из словаря
Обновили функцию get_detail_card_by_id - сделали поиск карточки по ID в словаре и возврат шаблона card_detail.html ИЛИ 404
commit: lesson_51: доделал каталог карточек и детальное отображение карточки по ID

Собственные шаблонные теги через simple_tag
Создали тег шаблона markdown_to_html через simple_tag в файле cards/templatetags/markdown_to_html.py
Протестировали его в представлении card_detail в шаблоне card_detail.html
commit: lesson_51: создал собственный тег шаблона markdown_to_html через simple_tag

Фильтры в шаблонах
Создали папку static в приложении cards и подключили статику в шаблоне base.html
Создали папку static в приложении cards
Создали папку cards в папке static
В ней создали папку css и файл main.css, а так же папку js и файл main.js
Создали тестовые стили и скрипт
Подключили статику в шаблоне base.html через тег {% load static %} и тег {% static %}
Подключили стили и скрипт в шаблоне base.html
Проверили работу статики на всех страницах
commit: lesson_51: подключил статику в шаблоне base.html

Работа с фильтрами в шаблонах
Посмотрели на работу следующих фильтров в шаблоне card_preview.html:

length
truncatechars
join
Так же, в шаблон был добавлен цикл для вывода тегов карточки.

commit: lesson_51: работа с фильтрами в шаблонах

Сделаем второй вариант шаблонного тега markdown_to_html через inclusion_tag
Создали второй вариант шаблонного тега markdown_to_html через inclusion_tag в файле cards/templatetags/markdown_to_html.py
Создали шаблон markdown_to_html.html в папке templates/cards
Протестировали его в представлении card_detail в шаблоне card_detail.html
Сравнили работу двух вариантов шаблонного тега
Lesson 52
Выполнили служебные миграции
Выполнили миграции командой python manage.py migrate Это создало служебные таблицы в базе данных, которые используются для работы с пользователями, сессиями, административной панелью и т.д.

Создали суперпользователя командой python manage.py createsuperuser

Сделали первую модель Card и миграции к ней
commit: lesson_52: первая модель cards

Знакомство с Shell Plus и работа с моделью Card в интерактивной оболочке Django
Установка Shell Plus командой pip install django-extensions
Добавление django_extensions в INSTALLED_APPS в файле settings.py
Запуск Shell Plus командой python manage.py shell_plus (для отображения SQL запросов в консоли - python manage.py shell_plus --print-sql
Для того, чтобы начать работать с моделью Card в интерактивной оболочке Django, нужно выполнить команду python manage.py shell_plus
commit: lesson_52: установка Shell Plus и подготовка ORM

CRUD Операции с этой моделью
Создание записи card = Card(question='Пайтон или Питон?!', answer='Пайтон') card.save()

Чтение записи card = Card.objects.get(pk=1) Мы можем добыть любые данные из записи, просто обратившись к атрибутам модели: card.question card.answer card.upload_date

Обновление записи card = Card.objects.get(pk=1) card.question = 'Питон или Пайтон?!!'

Удаление записи card = Card.objects.get(pk=1) card.delete()

Как можно откатить миграции?

Целиком для приложения cards командой python manage.py migrate cards zero
Вернуться к конкретной миграции python manage.py migrate cards 0001_initial
commit: lesson_52: базовые CRUD Операции с моделью Card

Подключение модели Card в административной панели
Создали файл admin.py в приложении cards (если его нет)
Зарегистрировали модель Card в административной панели
settings.py LANGUAGE_CODE = 'ru-ru' - для русского языка в админке
from django.contrib import admin
from .models import Card

# admin.site.register(Card)

@admin.register(Card)
class CardAdmin(admin.ModelAdmin):
    pass
создаем суперпользователя python manage.py createsuperuser
commit: lesson_52: подключил модель Card в административной панели

Методы объектного менеджера objects
all() - возвращает все объекты модели
filter() - возвращает объекты, которые соответствуют условиям фильтрации
get() - возвращает объект, который соответствует условиям фильтрации
exclude() - возвращает объекты, которые НЕ соответствуют условиям фильтрации
order_by() - возвращает объекты, отсортированные по указанному полю
first() - возвращает первый объект из выборки
last() - возвращает последний объект из выборки
count() - возвращает количество объектов в выборке
exists() - возвращает True, если хотя бы один объект соответствует условиям фильтрации
delete() - удаляет объекты, которые соответствуют условиям фильтрации
update() - обновляет объекты, которые соответствуют условиям фильтрации
Получили все карточки Card.objects.all() - получаем ленивый запрос LIMIT 21 НО!
for card in Card.objects.all():
    print(card.question)
Этот код не вызовет дополнительных запросов к базе данных, так как all() возвращает QuerySet, который хранит в себе все объекты модели, которые соответствуют условиям фильтрации.

Получили карточку по ID Card.objects.get(pk=1)
Получили все карточки с вопросом "Пайтон или Питон?!" Card.objects.filter(question='Пайтон или Питон?')
Получили первую карточку с вопросом "Пайтон или Питон?!" Card.objects.filter(question='Пайтон или Питон?').first()
Получаем с помощью лукапа contains все карточки с вопросом, содержащим слово "или" Card.objects.filter(question__contains='или')
Считаем карточки с вопросом "Пайтон или Питон?!" Card.objects.filter(question='Пайтон или Питон?').count()
Считаем все карточки Card.objects.all().count()
Получаем карточки добавленные во вторник Card.objects.filter(upload_date__week_day=3)
commit: lesson_52: методы объектного менеджера objects

commit: hw_30: done Загрузил решение ДЗ №30

Lesson 53
https://icons.getbootstrap.com/ - иконки для BS5 Их надо подключить по ссылке в шаблоне base.html

Сделаем чтение из БД в каталоге карточек
В файле views.py в функции catalog изменили возврат словаря на возврат списка карточек из БД
В файле-вставке include/card_preview.html изменили вставку данных id карточки на card.id (что соответствует полю id в БД)
commit: lesson_53: сделал чтение из БД в каталоге карточек

Сделаем детальное отображение карточки из БД по ID
В файле views.py в функции get_detail_card_by_id изменили возврат словаря на возврат карточки из БД
В файлах card_detail.html, card_preview.html изменили вставку данных просмотров и добавления в избранное на card.views и card.adds (что соответствует полям views и adds в БД)
commit: lesson_53: сделал детальное отображение карточки из БД по ID

Добавили теги в модель Card
Добавили поле tags в модель Card
Создали миграцию командой python manage.py makemigrations
Применили миграцию командой python manage.py migrate
Подключили модель Card в административной панели через декоратор @admin.register(Card)
commit: lesson_53: добавил теги в модель Card

Lookups
Еще раз пробежались по лукапам
get_object_or_404 для детального отображения карточки по ID
commit: lesson_53: get_object_or_404 для детального отображения карточки по ID

В общих чертах разобрали Q объекты и F объекты
Для get_detail_card_by_id сделали увеличение просмотров на + 1 через F объект
commit: lesson_53: F объект для увеличения просмотров карточки

hw_31:
Сортировка для каталога
sort - ключ для указания типа сортировки с возможными значениями: date, views, adds.
order - опциональный ключ для указания направления сортировки с возможными значениями: asc, desc. По умолчанию desc.
Примеры URL-запросов
Сортировка по дате добавления в убывающем порядке (по умолчанию): /cards/catalog/
Сортировка по количеству просмотров в убывающем порядке: /cards/catalog/?sort=views
Сортировка по количеству добавлений в возрастающем порядке: /cards/catalog/?sort=adds&order=asc
Сортировка по дате добавления в возрастающем порядке: /cards/catalog/?sort=date&order=asc
commit: hw_31: сделал сортировку для каталога

Lesson 54
Разборабли hw_31
Разборабли hw_32
Описали модели, чтобы они соответствовали базе данных
Подключили боевую базу данных SQLite
Создали служебные таблицы (просто сделали migrate)
Создали файлы миграций
Применили миграции в фейковом режиме --fake
Проверили что все работает
Сделали кликабельными теги в каталоге карточек
Установили django-debug-toolbar и настроили его
Оптимизировали запросы в каталоге
Подключили кеширование в настройках и кешировали каталог
Lesson 55
Типы отношений в базах данных и их реализация в Django
Создали модель Tag и связали ее с моделью Card через отношение ManyToManyField
Многие ко многим (ManyToManyField)
CRUD операции с моделями Card и Tag
Запустим shell plus с print sql командой python manage.py shell_plus --print-sql
Создадим объекты модели Tag:
tag1 = Tag.objects.create(name='Python')
Добавим теги к существующим записям. Просто по ID
card = Card.objects.get(pk=1)
tag = Tag.objects.get(pk=3)
card.tags.add(tag)
card.tags.all()
Добавим тег по имени "java_script", найдем ID и через ADD добавим к карточке
tag = Tag.objects.get(name="java_script")
В один запрос получим карточки по тегу "java_script"
Card.objects.filter(tags__name="java_script")
cards_by_tag = tag.cards.all()
Напишем новый запрос, который создаст карточку и добавит к ней теги
Получаем или создаем теги

Метод get_or_create в Django ORM — это удобный способ получить объект из базы данных, если он существует, или создать новый, если он не найден. Он возвращает кортеж, содержащий объект и булево значение: первый элемент кортежа — это сам объект, второй — флаг, указывающий, был ли объект создан в результате текущего вызова (True, если объект был создан, и False,

Если объект был получен из базы данных).

tag_names = ["python", "recursion"]
tags = [Tag.objects.get_or_create(name=name)[0] for name in tag_names]  
# Используем индекс [0] чтобы получить объект Tag
Создаем карточку new_card = Card(question="Как работает рекурсия в Python?", answer="Рекурсия - это...") new_card.save() # Сохраняем карточку в базу данных

Добавляем все теги к карточке for tag in tags: new_card.tags.add(tag)

Получим все карточки, у которых в теге есть "on" cards = Card.objects.filter(tags__name__icontains="on")

commit: lesson_55: многие ко многим (ManyToManyField)

Один ко многим (ForeignKey)
Создали модель категорий и добавили данные.
Один ко многим (ForeignKey)
Создали модель категорий и добавили данные.
Получить объект категории ID 1 cat1 = Category.objects.get(pk=1)

Получаем все карточки по категории cat1 cat1.cards.all()

Нам приходит на вход карточка и категория, которую мы хотим присвоить карточке. Мы не знаем есть такая категория или нет. Попробуем сделать это через get_or_create

new_card = Card.objects.create(question="Какой-то вопрос", answer="Какой-то ответ") some_cat = Category.objects.get_or_create(name="Новая категория")[0]

new_card.category = some_cat new_card.save()

commit: lesson_55: один ко многим (ForeignKey)

Агрегирующие функции и аннотации
Count, Sum, Avg, Max, Min. Метод values()

count - количество записей sum - сумма значений avg - среднее значение max - максимальное значение min - минимальное значение

values() - возвращает QuerySet, содержащий словари, представляющие объекты модели.

Получим категорию pk=1 cat1 = Category.objects.get(pk=1)
Посчитаем количество карточек в категории cat1.cards.count()
Получим карточку pk=1 card1 = Card.objects.get(pk=1)
Посчитаем количество карточек для каждой категории. Annotate categories_with_counts = Category.objects.annotate(cards_count=Count('cards')).all()
Посчитать сколько тегов у каждой карточки и отсортировать по убыванию cards_with_tag_counts = Card.objects.annotate(tags_count=Count('tags')).order_by('-tags_count').all()
Получим карточку с максимальным количеством тегов aggreate max_views = Card.objects.aggregate(max_views=Max('views')) max_tags_card = Card.objects.aggregate(max_tags=Max('tags'))
commit: lesson_55: кастомизация админки Двигались по конспекту (до создания собственного фильтра в админке)

Lesson 56
Делаем собственный фильтр в админки (Наследование от SimpleListFilter)
Сделали собственный фильтр, который позволяет фильтровать карточки по наличию кода в них class CardCodeFilter(SimpleListFilter)
commit: lesson_56: Создание своего фильтра SimpleListFilter

Поправили таблицы - к таблице многие-ко-многим добавили поле id - первичный ключ
Сделали миграции
commit: lesson_56: добавил первичный ключ к таблице многие-ко-многим

Установил django-djazzmin и настроил его
pip install django-djazzmin
Добавил djazzmin в INSTALLED_APPS в файле settings.py
commit: lesson_56: установил и настроил django-djazzmin

Сделал копию служебного шаблона change_form.html и вклинились в {% block after_field_sets %}
Добавил в админке карточек кнопку "Создать карточку с тегами" {% block object-tools-items %}
commit: lesson_56: кастомизация шаблона change_form.html

Lesson 58
Разобрали возможность делать dump и load данных в Django
Команды dumpdata и loaddata, а так же дополнительные настройки
Как сделать дамп приложения, как указать отсутпы и кодировку
Сделали дамп и загрузку данных
commit: lesson_58: dump.json

Формы в Django
Создали форму не связанную с моделью. Форма для добавления карточек
Создали представление, обрабатывающее метод POST и возвращающее форму
Создали шаблон для формы
Протестировали работу формы
Проверили валидацию формы
commit: lesson_58: базовая форма для добавления карточек

Дополнили шаблон с построчным рендером полей ввода
Добавили категорию как выпадающий список form.ChoiceField
commit: lesson_58: дополнил шаблон с построчным рендером полей ввода

Передали классы и атрибуты в форму через класс формы
Поправили шаблон и перешли на BS-5 с адаптивной версткой
Добавили обработку формы и сохранение данных в представлении
commit: lesson_58: BS5 и сохранение данных из формы

Описали собственный класс валидатор CodeBlockValidator
Подключили его в форме
Протестировали работу валидатора (пока слишком жесткий) - будем выключать и дописывать
commit: lesson_58: собственный валидатор CodeBlockValidator

Lesson 59
Написали форму связанную с моделью
Обновили представление, чтобы оно работало с формой связанной с моделью
Код получился вдвое короче
Добавили валидатор для поля tags в форме (отсутствие пробелов)
Добавили метод очистки тегов в форме
Проверили работу формы
commit: lesson_59: форма добавления карточек связанная с моделью

Базовая форма добавления файла
Минимальный комплект: класс формы, представление, шаблон
Получения файла через chunks() и сохранение его в файловую систему
Проблема: перезапись файла при одинаковых именах
commit: lesson_59: базовая форма добавления файла

Lesson 60 - Классовые представления
Разбор ДЗ с поиском в каталоге карточек
Модифицировали функцию-представление catalog в файле views.py так, чтобы она принимала GET-параметр search_query
Добавили в шаблон catalog.html форму для поиска карточек с GET-параметром search_query и радио-кнопками для выбора поля поиска
Протестировали работу поиска
Добавили отключение кеширования браузера для страницы каталога, чтобы видеть увеличение просмотров в катаолге
commit: lesson_60: разбор ДЗ с поиском в каталоге карточек

Добавили экземпляр пагинатора в представление catalog в файле views.py
Добавили работу с пагинатором в шаблоне catalog.html
commit: lesson_60: добавил пагинацию в каталог карточек

Классовые представления
Переписали функцию представления add_card на классовое представление с наследованием от View
commit: lesson_60: переписал функцию представления add_card на классовое представление

Переписали about и главную страницу на классовые представления (наследование от TemplateView)
Создали миксин, который добавляет к контексту меню, подмешали его в один класс
commit: lesson_60: переписал about и главную страницу на TemplateView

Добавили в AboutView и IndexView атрибут extra_context и добавили в него подсчет реального количества карточек и пользователей
commit: lesson_60: добавил в AboutView и IndexView подсчет реального количества карточек и пользователей

Lesson 61
ListView
Переписали представление catalog на классовое представление ListView
Добавили жадную загрузку связанных объектов
Использовали __iregex для РАБОЧЕГО регистронезависимого поиска вместо __icontains (актуально для SQLite)
Кешировали каталог силами шаблонизатора
Использовали page_obj.paginator.count для подсчета количества карточек (не иницирует новых запросов к БД)
Использовали переменные для кеша, которые позволяют кешировать разные варианты страницы (по запросам и сортировкам){% cache 90 catalog_content page_obj.number sort order search_query %}
commit: lesson_61: catalog на классовое представление ListView и кеширование

DetailView
Переписали представление get_detail_card_by_id на классовое представление DetailView
Обновили шаблон card_detail.html для работы с классовым представлением
commit: lesson_61: get_detail_card_by_id на классовое представление DetailView

Кеширование MenuMixin
Использовали from django.core.cache import cache для кеширования меню, так как оно делало с каждой страницы по 2 запроса в БД
commit: lesson_61: кеширование меню с помощью cache

CreateView
Переписали представление добавления карточки на классовое представление CreateView - AddCardCreateView(MenuMixin, CreateView)
commit: lesson_61: добавление карточки на классовое представление CreateView

Lesson 62
UpdateView и DeleteView
Добавили представления UpdateView и DeleteView для редактирования и удаления карточек
Внесли в форму CardForm неудачную правку в инициализатор, попытка изменить теги на строку при открытии формы редактирования
А так же удачную правку для тегов, чтобы они на самом деле обновлялись (а не только добавлялись)
Шаблон для 404 ошибки (работает пока только в боевом режиме DEBUG=False)
commit: lesson_62: UpdateView и DeleteView и 404

Users app
Создали приложение users и подключили его в INSTALLED_APPS
Подготовили маршруты и namespace для приложения users
commit: lesson_62: users app и подготовка маршрутов

прописали функции-представления для авторизации и выхода из системы
создали шаблон для входа в систему
LoginUserForm - форма для входа в систему
Протестировали вход и выход из системы
Нашли в браузере куки и сессии
commit: lesson_62: функции-представления для авторизации и выхода из системы

redirect_field_name = 'next' во вьюшке добавления карточек
Так же, добавили миксин LoginRequiredMixin для защиты представлений от неавторизованных пользователей
В шаблон login.html добавили next для перехода на страницу, с которой пришел пользователь <input type="hidden" name="next" value="{{ request.GET.next }}">
Пофиксили редирект при успешной авторизации return redirect(request.POST.get('next', 'catalog')) Это позволяет переходить на страницу, с которой пришел пользователь после авторизации
Поработали с меню, теперь там отображается имя пользователя и ссылка на выход из системы
commit: lesson_62: защита представлений от неавторизованных пользователей и перенаправление

Lesson 63
#BUG: Нашли косяк с кешированием представления по тегам (отображается только кеш первого тега) #TODO: Добавить оптимизация шаблонов каталога

base_catalog.html
include/card_preview.html
card_detail.html
catalog.html
profile_cards.html ?
cards_by_tag.html (наследуется от base_catalog.html)
cards_by_category.html (наследуется от base_catalog.html)
Переписали функцию логина на LoginUser(LoginView)
Использовали LoginView вместо функции login_user - это классовое представление для входа в систему
В нем использовали служебную форму AuthenticationForm для входа в систему
А так же прописали success_url для перехода после успешного входа с проверкой на next
commit: lesson_63: переписал функцию логина на LoginUser(LoginView)

Написали свою форму с наследованием от AuthenticationForm и добавили в нее BS5 стили
Переписали представление выхода из системы на LogoutUser(LogoutView)
Добавили оформления в шаблон login.html
commit: lesson_63: своя форма входа и выхода из системы

Поэкспериментировали с LoginRequiredMixin и порядком его указания в классе представления
MenuMixin никак не влияет на работу LoginRequiredMixin
Прописал в настройках LOGIN_URL для того, чтбы не делать это в каждом защищенном представлении
Убрал login_url из 2 защищенных представлений и проверил работу
commit: lesson_63: LoginRequiredMixin и LOGIN_URL

Добавление пользователя в описание карточки
author = models.ForeignKey(get_user_model(), on_delete=models.SET_NULL, related_name='cards', null=True, default=None, verbose_name=_('Автор'))
Добавили пользователя в шаблоны отображения карточек
Модифицировали view для добавления карточки, чтобы автором был текущий пользователь
commit: lesson_63: добавил пользователя в описание карточки

class LogoutUser(LogoutView): next_page = reverse_lazy('users:login')
Поправили urls.py для приложения users c использованием класса LogoutUser
commit: lesson_63: LogoutUser(LogoutView)

Регистрация пользователя через простую форму связанную с моделью RegisterUserForm(forms.ModelForm):
Функция представления register_user для регистрации пользователя
Шаблон register.html для регистрации пользователя
Сообщение спасибо за регистрацию register_done.html
commit: lesson_63: регистрация пользователя

Lesson 64
Класс регистрации пользователя RegisterUser
Переписали функцию регистрации на класс RegisterUser(CreateView) - специализированного родителя нет, поэтому используем CreateView
Поправили urls.py для приложения users c использованием класса RegisterUser
Проверили, что старая форма не хеширует пароли (раньше это было в функции вьюшки)
Переписали старую форму на класс RegisterUserForm(UserCreationForm) - специлизированный родитель для регистрации пользователя
Протестировали хеширование пароля (Есть!)
commit: lesson_64: класс регистрации пользователя RegisterUser

Авторизация опционально через email или username
Создаем файл бэкенда аутентификации users/authentication.py
Определяем в нем собственный бэкенд
Подключаем его в настройках AUTHENTICATION_BACKENDS
Указываем там стандартный бэкенд django.contrib.auth.backends.ModelBackend и наш собственный users.authentication.EmailAuthBackend
Поправили форму входа LoginUserForm (подпись что вы можете войти по email или username)
commit: lesson_64: авторизация опционально через email или username

Начали работу над личным кабинетом
Шаблоны
Создали шаблон base_profile.html который расширяет base.html и служит основой для личного кабинета
Создали шаблон profile.html который расширяет base_profile.html и содержит информацию о пользователе а так же возможность внести изменения в профиль
Создали include profile_nav.html для навигации по личному кабинету
Создали шаблон password_change_form.html для изменения пароля
Создали шаблон password_change_done.html для успешного изменения пароля
Создали шаблон profile_cards.html для отображения карточек пользователя
Маршруты
users/profile/ - ProfileUser - личный кабинет пользователя
users/password_change/ - UserPasswordChange - изменение пароля пользователя
users/profile_cards/ - UserCardsView - карточки пользователя
Представления
UserPasswordChange - изменение пароля пользователя. Наследуется от PasswordChangeView - стандартного класса для изменения пароля. Использует пользовательскую форму UserPasswordChangeForm, которая наследуется от PasswordChangeForm
UserPasswordChangeDone - успешное изменение пароля пользователя. Наследуется от TemplateView
UserCardsView - карточки пользователя. Наследуется от ListView. Переопределяет метод get_queryset для получения карточек пользователя
commit: lesson_64: начал работу над личным кабинетом

Lesson 65
Обзор того, что сделали на прошлом уроке
Пробежались по шаблонам, маршрутам и представлениям личного кабинета

Почему у нас некоторые поля формы не редактируемые в профиле?

Почему на текущий момент не сохраняются изменения в профиле?

На данном пути 2 варианта развития: - работа с аватарами, восстановление пароля через email

Закончим работу с ЛК пользователя

Расширили модель пользователя
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    photo = models.ImageField(upload_to='users/images/%Y/%m/%d/', blank=True, null=True, verbose_name='Фотография')
    date_birth = models.DateTimeField(blank=True, null=True, verbose_name='Дата рождения')

    def __str__(self):
        return self.username
В Django, AbstractUser - это базовый класс для модели пользователя, который включает в себя большинство полей и методов, необходимых для аутентификации и авторизации пользователей. Он включает такие поля, как username, password, email, first_name, last_name, is_staff, is_active, date_joined и другие.

Когда вы создаете свой собственный класс User, наследуясь от AbstractUser, вы переопределяете стандартную модель пользователя Django. Это позволяет вам добавить дополнительные поля, такие как photo и date_birth, которые не включены в стандартную модель пользователя.

Ваш класс User включает следующие поля:

photo: Это поле ImageField, которое позволяет пользователям загружать фотографии. Параметр upload_to указывает, где эти фотографии должны быть сохранены. В данном случае, они сохраняются в подкаталоге users/images/%Y/%m/%d/ каталога MEDIA_ROOT. Параметры blank=True, null=True указывают, что это поле не является обязательным.
date_birth: Это поле DateTimeField, которое позволяет пользователям указывать свою дату рождения. Оно также не является обязательным.
Причина, по которой вы используете наследование от AbstractUser, а не связь "один к одному" с другой моделью для хранения дополнительной информации о пользователе, заключается в том, что это делает вашу модель пользователя более гибкой и удобной в использовании. Вместо того чтобы каждый раз, когда вам нужна дополнительная информация о пользователе, получать ее из связанной модели, вы можете просто обратиться к полям photo и date_birth напрямую, как если бы они были частью стандартной модели пользователя.

В Django, параметр upload_to в поле ImageField или FileField используется для указания подкаталога внутри MEDIA_ROOT, где будут сохраняться загруженные файлы.

Строка 'users/images/%Y/%m/%d/' в upload_to определяет путь к подкаталогу, где будут сохраняться файлы. В этом пути используются специальные символы %Y, %m и %d, которые заменяются на текущий год, месяц и день соответственно. Это позволяет автоматически организовать загруженные файлы по датам, что может быть полезно, если вы ожидаете большое количество загружаемых файлов.

Таким образом, если пользователь загрузит файл 5 июля 2022 года, файл будет сохранен в подкаталоге users/images/2022/07/05/ каталога MEDIA_ROOT.

Пожалуйста, учтите, что MEDIA_ROOT должен быть предварительно определен в настройках вашего Django проекта. Это корневой каталог, где Django будет сохранять все загруженные файлы.

Установим pillow для работы с изображениями pip install pillow
Обновим requirements.txt pip freeze > requirements.txt
Подключим новую модель пользователя в настройках AUTH_USER_MODEL = 'users.User'
Так как пользователь, достаточно важная часть приложения, пришлось пересоздать миграции.
Удалил все миграции всех приложений.
Удалил базу данных.
Создал новые миграции.
Применил миграции.
Восстановил контент из дампа командой python manage.py loaddata dump.json
commit: lesson_65: расширил модель пользователя

Починим фотографии в профиле
Для этого нужно определить две вещи в настройках:
MEDIA_ROOT - корневой каталог для загружаемых файлов
MEDIA_URL - URL, по которому можно получить доступ к загружаемым файлам
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
Правки в главный urls.py для отображения медиафайлов в режиме отладки
from django.conf.urls.static import static
from django.conf import settings
if settings.DEBUG:
    import debug_toolbar

    urlpatterns = [
                      path('__debug__/', include(debug_toolbar.urls)),
                      # другие URL-паттерны
                  ] + urlpatterns
    
    # Добавляем обработку медиафайлов
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
Правки в nav_menu.html для кликабельности username
 <a class="nav-link" href="{% url 'users:profile' %}">{{ user.username }}</a>
А так же мелкие правки в стили для отображения фотографии пользователя

commit: lesson_65: починил фотографии в профиле

Доделываем смену пароля в ЛК
Отсутствовал маршрут в urls.py для UserPasswordChangeDone Добавили его и протестировали работу смены пароля

commit: lesson_65: доделал смену пароля в ЛК

Восстановление пароля через email
Для этого нам необходимо подготовить целый ряд представлений, шаблонов и форм:

Итого для работы с паролями:

Классы и их функциональность
PasswordChange

Родитель: PasswordChangeView
Атрибуты:
template_name: Указать путь к шаблону формы смены пароля.
form_class: Указать класс формы для смены пароля.
success_url: Использовать reverse_lazy для указания URL-адреса перенаправления после успешной смены пароля.
extra_context: Словарь с дополнительным контекстом, например {'title': 'Смена пароля'}.
Методы:
form_valid: Метод, вызываемый при успешной валидации формы. Может быть переопределен для добавления дополнительной логики.
PasswordChangeDone

Родитель: TemplateView
Атрибуты:
template_name: Указать путь к шаблону страницы, подтверждающей успешное изменение пароля.
extra_context: Словарь с дополнительным контекстом, например {'title': 'Пароль успешно изменен'}.
PasswordReset

Родитель: PasswordResetView
Атрибуты:
template_name: Указать путь к шаблону формы запроса на сброс пароля.
form_class: Указать класс формы для запроса сброса пароля.
email_template_name: Путь к шаблону email, который будет отправлен для сброса пароля.
success_url: Использовать reverse_lazy для указания URL-адреса перенаправления после запроса на сброс.
subject_template_name: Путь к шаблону темы email.
Методы:
form_valid: Метод для дополнительной обработки после отправки формы.
PasswordResetDone

Родитель: TemplateView
Атрибуты:
template_name: Указать путь к шаблону страницы, подтверждающей отправку инструкций по сбросу пароля.
extra_context: Словарь с дополнительным контекстом, например {'title': 'Инструкции отправлены'}.
PasswordResetConfirm

Родитель: PasswordResetConfirmView
Атрибуты:
template_name: Указать путь к шаблону формы для ввода нового пароля.
form_class: Указать класс формы для ввода нового пароля.
success_url: Использовать reverse_lazy для указания URL-адреса перенаправления после успешного сброса пароля.
Методы:
form_valid: Метод для дополнительной обработки после успешной смены пароля.
PasswordResetComplete

Родитель: TemplateView
Атрибуты:
template_name: Указать путь к шаблону страницы, подтверждающей успешное обновление пароля.
extra_context: Словарь с дополнительным контекстом, например {'title': 'Пароль успешно обновлен'}.
Служебный синтаксис в методах
reverse_lazy('name_of_route'): Используется для отложенного получения URL по имени маршрута.
form_valid(form): Вызывается, когда форма проходит валидацию. Обычно используется для переопределения стандартной логики, например, для выполнения дополнительных действий с объектом перед его сохранением.
Эти элементы должны быть включены в классы и методы для обеспечения функциональности смены и восстановления пароля, а также управления потоком пользователя в приложении Django.

Таблица классов и представлений:
Класс	Файл	Родитель	Описание	Использование
PasswordChange	views.py	PasswordChangeView	Класс для смены пароля аутентифицированного пользователя.	Смена пароля
PasswordChangeDone	views.py	TemplateView	Отображает страницу об успешном изменении пароля.	Подтверждение смены пароля
PasswordReset	views.py	PasswordResetView	Обработчик для инициирования процесса сброса пароля.	Восстановление пароля
PasswordResetDone	views.py	TemplateView	Отображает страницу, подтверждающую отправку инструкций.	Подтверждение отправки письма
PasswordResetConfirm	views.py	PasswordResetConfirmView	Позволяет пользователю ввести новый пароль после сброса.	Ввод нового пароля
PasswordResetComplete	views.py	TemplateView	Отображает страницу об успешном обновлении пароля.	Успешное обновление пароля
Шаблоны
Шаблоны сброса пароля Django:

password_reset_email.html: используется для отправки электронного письма с ссылкой для сброса пароля.
password_reset_form.html: используется для отображения формы сброса пароля.
password_reset_confirm.html: используется для отображения страницы подтверждения сброса пароля.
password_reset_done.html: используется для отображения страницы с сообщением о том, что пароль был успешно сброшен.
password_change_email.html: используется для отправки электронного письма с уведомлением о смене пароля.
password_change_form.html: используется для отображения формы изменения пароля.
password_change_done.html: используется для отображения страницы с сообщением о том, что пароль был успешно изменен.
Описание каждого шаблона:

password_reset_email.html:

Этот шаблон используется для отправки электронного письма с ссылкой для сброса пароля.
Шаблон должен содержать ссылку, которая направляет пользователя на страницу сброса пароля.
Ссылка должна содержать уникальный идентификатор пользователя и токен сброса пароля.
Шаблон также может содержать сообщение с инструкциями о том, как сбросить пароль.
password_reset_form.html:

Этот шаблон используется для отображения формы сброса пароля.
Форма должна содержать поля для ввода нового пароля и подтверждения нового пароля.
Форма должна также содержать скрытое поле с токеном сброса пароля.
Когда пользователь отправляет форму, Django проверит токен сброса пароля и, если он действителен, сбросит пароль пользователя.
password_reset_confirm.html:

Этот шаблон используется для отображения страницы подтверждения сброса пароля.
Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно сброшен.
Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.
password_reset_done.html:

Этот шаблон используется для отображения страницы с сообщением о том, что пароль был успешно сброшен.
Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно сброшен.
Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.
password_change_email.html:

Этот шаблон используется для отправки электронного письма с уведомлением о смене пароля.
Шаблон должен содержать сообщение с информацией о том, что пароль пользователя был изменен.
Шаблон также может содержать ссылку, которая направляет пользователя на страницу изменения пароля.
password_change_form.html:

Этот шаблон используется для отображения формы изменения пароля.
Форма должна содержать поля для ввода текущего пароля, нового пароля и подтверждения нового пароля.
Когда пользователь отправляет форму, Django проверит текущий пароль пользователя и, если он верен, изменит пароль пользователя.
password_change_done.html:

Этот шаблон используется для отображения страницы с сообщением о том, что пароль был успешно изменен.
Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно изменен.
Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.
Промежуточный коммит commit: lesson_65: промежуточный коммит восстановление пароля через email

Маршруты
Маршрут для сброса пароля
Маршрут для подтверждения сброса пароля
Маршрут для ввода нового пароля
Маршрут для завершения сброса пароля
Settings
Настраиваем EMAIL_BACKEND для вывода в консоль

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
Тестирование прошло успешно. Мы увидели емейл в консоли, который отправился при запросе сброса пароля После этого мы успешно сменили пароль пользователю

commit: lesson_65: восстановление пароля через email - тест в терминале

Сделали восстановление пароля через email

commit: lesson_65: восстановление пароля через email

Идеальный план на последующие уроки (будет сокращен)
Lesson 66 - Деплой на TimeWeb с автоматическим CI/CD
Подготовка к деплою
Регистрация на TimeWeb. https://timeweb.cloud/r/pj17346
Выбор тарифа и создание виртуального сервера.
Покупка домена и настройка его на TimeWeb.
Подгтовка проекта к деплою
Убедитесь что в проекте нет лишних файлов и папок.
Создайте файл requirements.txt с зависимостями проекта.
Если вы создавали .env файл, добавьте его в .gitignore.
Убедитесь что .env.example содержит все необходимые переменные.
Если в вашей БД есть контент, создайте дамп БД
Можете прогнать тест. Просто склонируйте проект в соседнюю папку и попробуйте запустить.
Команды для подготовки приложения к запуску на сервере
Деплой
commit: lesson_66: подготовка к деплою

Настройка дополнительных возможностей
Настройка SSL-сертификатов через Let's Encrypt для безопасного соединения.
Настройка автоматического обновления SSL-сертификатов.
Настройка автоматического деплоя через CI/CD.
Концепция DNS имен для домена.
Прописывание DNS имен для домена pydeck.ru.
commit: lesson_66: развернули приложение и прописали DNS имена для домена pydeck.ru

Дополнительная настройка для работы проекта
Настройка DEBUG в settings.py для отладочного режима. Чтобы на сервере не отображались отладочные сообщения, установите DEBUG = False и добавьте домен сервера в список ALLOWED_HOSTS. DEBUG = os.getenv('DEBUG')

Настройка ALLOWED_HOSTS в settings.py для домена pydeck.ru. ALLOWED_HOSTS - это список хостов, которые могут обращаться к нашему сайту ALLOWED_HOSTS = ['pydeck.ru', 'www.pydeck.ru', 'localhost', '127.0.0.1']

Настройка CSRF_TRUSTED_ORIGINS в settings.py для безопасной работы с формами. CSRF_TRUSTED_ORIGINS - это список доменов, с которых можно отправлять POST-запросы без токена CSRF CSRF_TRUSTED_ORIGINS = ['https://pydeck.ru', 'https://www.pydeck.ru']

Добавление IF DEBUG для отладочной панели Django. INTERNAL_IPS - это список IP-адресов, с которых можно получить доступ к отладочной панели Django if DEBUG:
INTERNAL_IPS = [ '127.0.0.1', ]

commit: lesson_66: дополнительная настройка для работы проекта

Lesson 67 - Концепция авторизации через соцсети
Обзор протокола OAuth2.0
Введение в OAuth2.0 и его принципы.
Различия между OAuth и OpenID Connect.
Пример работы OAuth2.0 на практике в Django.
Подготовка проекта к авторизации через соцсети
Устанавливаем библиотеку social-auth-app-django и добавляем ее в requirements.txt https://python-social-auth.readthedocs.io/en/latest/index.html
pip install social-auth-app-django pip freeze > requirements.txt

Добавляем приложение social_django в INSTALLED_APPS в settings.py
INSTALLED_APPS = [
    ...
    'social_django',
]
Добавляем настройки settings.py AUTHENTICATION_BACKENDS - список бэкендов аутентификации, для работы с соцсетями MIDDLEWARE - список промежуточных слоев, для обработки исключений TEMPLATES - список контекстных процессоров, для передачи данных в шаблоны SOCIAL_AUTH_URL_NAMESPACE - пространство имен для URL-адресов авторизации
AUTHENTICATION_BACKENDS = (
    'social_core.backends.github.GithubOAuth2',
    'social_core.backends.vk.VKOAuth2',
    'django.contrib.auth.backends.ModelBackend',
)
########
MIDDLEWARE = [
    ...
    'social_django.middleware.SocialAuthExceptionMiddleware',
]
########
TEMPLATES = [
    {
        ...
        'OPTIONS': {
            'context_processors': [
                ...
                'social_django.context_processors.backends',
                'social_django.context_processors.login_redirect',
            ],
        },
    },
]

SOCIAL_AUTH_URL_NAMESPACE = 'social'
Добавляем в .env и env.example переменные для авторизации через GitHub и VK
GITHUB_KEY=None GITHUB_SECRET=None VK_KEY=None VK_SECRET=None

Настройки в settings.py для авторизации через GitHub и VK
SOCIAL_AUTH_URL_NAMESPACE = 'social'
SOCIAL_AUTH_GITHUB_KEY = os.getenv('GITHUB_KEY')
SOCIAL_AUTH_GITHUB_SECRET = os.getenv('GITHUB_SECRET')

SOCIAL_AUTH_VK_OAUTH2_KEY = os.getenv('VK_KEY')
SOCIAL_AUTH_VK_OAUTH2_SECRET = os.getenv('VK_SECRET')

LOGIN_REDIRECT_URL = '/users/profile/'
LOGOUT_REDIRECT_URL = '/'
Добавляем URL-адреса для авторизации через соцсети в urls.py
from django.urls import include, path

urlpatterns = [
    ...
    path('social-auth/', include('social_django.urls', namespace='social')),
]
Добавляем в шаблон profile.html кнопки для авторизации через GitHub и VK
<form method="post" action="{% url 'users:link_social_account' %}">
  {% csrf_token %}
  <button type="submit" name="provider" value="github" class="btn btn-dark">Привязать GitHub</button>
  <button type="submit" name="provider" value="vk" class="btn btn-dark">Привязать VK</button>
</form>
Создаем представление для привязки соцсетей к пользователю в views.py приложения users
from django.views import View
from django.shortcuts import redirect
from social_django.utils import psa

class SocialAuthView(View):

    @psa('social:complete')
    def save_oauth_data(self, request, backend):
        user = request.user
        if backend.name == 'github':
            user.github_id = backend.get_user_id(request)
        elif backend.name == 'vk':
            user.vk_id = backend.get_user_id(request)
        user.save()
        return redirect('users:profile')

    def post(self, request, *args, **kwargs):
        if 'provider' in request.POST:
            provider = request.POST['provider']
            if provider == 'github':
                return redirect('social:begin', backend='github')
            elif provider == 'vk':
                return redirect('social:begin', backend='vk')
        return redirect('users:profile')
commit: lesson_67: подготовка проекта к авторизации через соцсети

Обновление моделей и представлений
Добавление полей для хранения данных соцсетей в модель пользователя.
class User(AbstractUser):
    ...
    github_id = models.CharField(max_length=255, blank=True, null=True)
    vk_id = models.CharField(max_length=255, blank=True, null=True)
Создание миграций и применение изменений в базе данных.
python manage.py makemigrations python manage.py migrate

commit: lesson_67: обновление моделей для авторизации через соцсети

Обновление маршрутов
Добавление маршрутов для авторизации через соцсети в urls.py приложения users.
from django.urls import path
from .views import SocialAuthView

urlpatterns = [
    ...
    path('link-social-account/', SocialAuthView.as_view(), name='link_social_account'),
    path('save-oauth-data/<str:backend>/', SocialAuthView.as_view(), name='save_oauth_data'),
]
commit: lesson_67: обновление маршрутов для авторизации через соцсети

Обновление шаблона login.html
 <h3>Или зайдите через:</h3>
            <a href="{% url 'social:begin' 'vk' %}" class="btn btn-dark">ВКонтакте</a>
            <a href="{% url 'social:begin' 'github' %}" class="btn btn-dark">GitHub</a>
commit: lesson_67: обновление шаблона login.html

Альтернативный вариант: регистрация через соцсети
Обзор преимуществ и недостатков регистрации через соцсети.
Пример реализации регистрации через соцсети с помощью social-auth-app-django.
Обсуждение вопросов безопасности и конфиденциальности.
Lesson 68 - Концепция Django сигналов
Введение в Django сигналы
Обзор концепции сигналов в Django.
Зачем нужны сигналы и их преимущества.
Примеры встроенных сигналов в Django.
Создание и настройка сигналов
Настройка сигнала для отправки уведомлений при создании новой карточки.
Настройка сигнала для обновления профиля пользователя после изменения данных.
Настройка сигнала для очистки кеша после обновления данных.
Примеры использования сигналов
Настройка сигнала для отправки email после регистрации пользователя.
Настройка сигнала для логирования действий пользователя.
Настройка сигнала для автоматической генерации отчетов.
Подписка на категории карточек
Добавление функционала подписки пользователя на категории.
Создание модели для хранения подписок.
Настройка сигнала для отправки уведомлений о новых карточках в подписанных категориях.
Реализация всплывающих уведомлений при входе на сайт.
Создание страницы в ЛК для просмотра и управления уведомлениями.
Закрытие уведомлений
Реализация функционала закрытия уведомлений.
Обновление модели уведомлений для хранения состояния прочитанности.
Настройка сигнала для обновления состояния уведомлений при закрытии.
Обсуждение полезных примеров сигналов
Отправка уведомлений в Telegram при обновлении данных.
Автоматическое обновление кеша после изменений в базе данных.
Логирование ошибок и уведомление администратора.
Lesson 69 - Создание Django приложения для Telegram бота
Настройка приложения Telegram бота
Регистрация нового бота в Telegram и получение токена.
Установка и настройка библиотеки python-telegram-bot.
Создание нового Django приложения для бота.
Интеграция бота с сайтом
Добавление кнопки подписки на уведомления в ЛК пользователя.
Настройка URL для общения с ботом.
Реализация начального диалога с ботом и сохранение user id Telegram в профиль пользователя.
Отправка уведомлений через бота
Настройка сигнала для отправки уведомлений в Telegram.
Тестирование отправки сообщений через бота.
Настройка команды для массовой отправки уведомлений.
Улучшение функциональности бота
Реализация команды для получения списка новых карточек.
Реализация команды для отписки от уведомлений.
Реализация команды для получения информации о пользователе.
Безопасность и логирование
Настройка проверки подлинности сообщений от Telegram.
Настройка логирования действий бота.
Настройка уведомлений о сбоях и ошибках бота.
Тестирование и отладка
Тестирование функционала бота на тестовой среде.
Обработка и исправление возможных ошибок.
Оптимизация кода и производительности бота.
Развертывание и мониторинг
Развертывание бота на сервере.
Настройка мониторинга и автоматического перезапуска бота.
Обзор инструментов для мониторинга и отладки.
Lesson 70 - Завершение проекта и обсуждение будущих планов
Обзор и рефакторинг проекта
Проведение общего обзора всего проекта.
Рефакторинг кода и удаление неиспользуемых частей.
Оптимизация производительности и улучшение структуры кода.
Финальные тесты и багфиксы
Проведение полного тестирования всех компонентов проекта.
Исправление найденных ошибок и багов.
Обновление документации и комментариев в коде.
Дополнительные функции и улучшения
Обсуждение возможных дополнительных функций для проекта.
Реализация мелких улучшений и фич.
Настройка финальной версии CI/CD для автоматического деплоя.
Подготовка к выпуску
Подготовка проекта к релизу.
Настройка домена и SSL-сертификатов.
Создание страницы "О проекте" и "Контакты" на сайте.
Обсуждение будущих планов
Обсуждение возможных направлений для дальнейшего развития проекта.
Обзор новых технологий и их возможного применения в проекте.
Планирование следующего этапа разработки.
Завершение и обратная связь
Проведение итоговой встречи с обсуждением результатов.
Сбор обратной связи и пожеланий.
Планирование будущих курсов и обучающих программ.
Эти планы помогут завершить проект, внедрить важные функциональные компоненты и подготовить его к реальному использованию.
